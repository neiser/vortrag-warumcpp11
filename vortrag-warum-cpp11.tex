\pdfminorversion=4
\documentclass[t,ngerman]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{listings}
\usepackage{csquotes}

\lstset{language=[11]C++,numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt,
   basicstyle={\small\ttfamily}, moredelim=**[is][\color{red}]{@}{@},
 commentstyle=\color{gray},
literate=={=}{a}1}

\usepackage[sfdefault,scaled=1,book]{FiraSans}
\usepackage[lining]{FiraMono}

\usecolortheme{rose,seahorse}
\useinnertheme{rounded,circles}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{%
  \raisebox{5pt}{\makebox[\paperwidth]{\hfill\makebox[10pt]{\scriptsize\insertframenumber}}}}

\newcommand\Cpp{%
  C\kern-.03em\raise.15ex\hbox{++}%
  \spacefactor1000}

\author{Andreas Neiser}
\title{Warum \Cpp{}11?}
\date{\today}

\begin{document}

\frame{\maketitle}


\begin{frame}[fragile]
  \frametitle{AAA -- Almost always \lstinline!auto! -- Fast immer \lstinline!auto! }
  Statt Typ hinzuschreiben, einfach \lstinline!auto! stattdessen. \\ Der Compiler findet's schon raus, hoffentlich\ldots
  
\begin{lstlisting}
typedef vector<int> nums_t; 
static const int t[] = {1,2,3};
nums_t a(t,t+sizeof(t)/sizeof(t[0])); 
for(nums_t::iterator i=a.begin();  i != a.end(); ++i)
  *i *= 2;
\end{lstlisting}

Wo weiß der Compiler eigentlich eh schon, \\ was für ein Typ die Variable hat?

\pause 
\begin{lstlisting}
static const int t[] = {1,2,3};
vector<int> a(t,t+sizeof(t)/sizeof(t[0])); 
for(@auto@ i=a.begin();  i != a.end(); ++i)
  *i *= 2;
\end{lstlisting}

\pause 
\begin{block}{}
  \centering
  \lstinline!auto! macht Code schlanker und allgemeiner\\ \small (und man kann über wichtigere Dinge nachdenken als \lstinline|typedef|s) 
\end{block}
  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Geschweifte Klammern und \lstinline|std::initializer_list|}
\begin{lstlisting}
vector<int> a{1,2,3}; // oh, wie einfach!
for(auto i=a.begin();  i != a.end(); ++i)
  *i *= 2;
\end{lstlisting}

\pause
Genauso geht:
\begin{lstlisting}
struct my_t { 
  int A; int B;
  my_t(int a, int b) : A(a), B(b) {}
};
vector<my_t> a{{1,2},{3,4}};  
\end{lstlisting}

\pause
Aber {\color{red}Vorsicht} bei:\\
\begin{lstlisting}
vector<int> a(5);
vector<int> b{5};
\end{lstlisting}

\pause 
\begin{block}{}
  \centering
  \lstinline!{...}! macht das Initialisieren \enquote{natürlich hübsch}
\end{block}

\end{frame}


\begin{frame}[fragile]
  \frametitle{for-ranged loops und nochmal \lstinline!auto!}
\begin{lstlisting}
vector<int> a{1,2,3};
for(auto i=a.begin();  i != a.end(); ++i)
  *i *= 2;
\end{lstlisting}

\pause
\ldots{}kann man auch so schreiben:
\begin{lstlisting}
vector<int> a{1,2,3};
for(auto& v : a)
  v *= 2;
\end{lstlisting}

\pause
Hm, aber was ist mit:
\begin{lstlisting}
@const@ vector<int> a{1,2,3};
for(auto& v : a)
  v *= 2;
\end{lstlisting}

\pause
\begin{block}{}
  \centering
  for-ranged loops machen STL container endlich benutzbar,
  und \lstinline!auto! ist schlau genug für \lstinline!const!-correctness
\end{block}
  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Zero-overhead byte-packing}
  \begin{lstlisting}
auto packed = Make(0,1,1,0,
                   1,0,0,1,	
                   1,0,0,1,
                   0,1,1,0); // should be {0x69, 0x96}
  \end{lstlisting}

\pause
Eine Idee:
\begin{lstlisting}
template<typename... Bools>
auto Make(Bools... bools) {
  const vector<bool> b{(bool)bools...};
  vector<byte_t> a(b.size()/8);
  for(auto i=0u; i<a.size(); ++i)
    a[a.size()-i-1] = (b[8*i+7] << 7) | (b[8*i+6] << 6) 
                      | /* ... | */  b[8*i+0];
  return a;
}
\end{lstlisting}
  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Zero-overhead byte-packing II}
  
Erstmal: 
\begin{lstlisting}
template<typename... Bools>
auto Make(Bools... bools) {
  constexpr auto nBools = sizeof...(bools);
  static_assert(nBools % 8 == 0, "Bools not packable");
  auto a = array<byte_t, nBools/8>();
  Fill(a, nBools/8, bools...);
  return a;
}
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Zero-overhead byte-packing III}

Dann:
\begin{lstlisting}
template<size_t N, typename... Bools>
void Fill(array<byte_t, N>& a,
          size_t i,
          bool b7, bool b6, bool b5, bool b4,
          bool b3, bool b2, bool b1, bool b0,
          Bools... bools) {
  a[N-i] =  (b7 << 7) /* | ... */ |  b0;
  Fill(a, i-1, bools...);
}

template<size_t N>
void Fill(array<byte_t, N>&, size_t) {}
\end{lstlisting}


    
\end{frame}

\end{document}